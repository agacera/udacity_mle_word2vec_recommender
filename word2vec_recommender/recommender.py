#AUTOGENERATED! DO NOT EDIT! File to edit: dev/02_recommender.ipynb (unless otherwise specified).

__all__ = ['logger', 'KnnRecommender']

#Cell
import logging
import random
from typing import List, NamedTuple, Tuple
from datetime import datetime
from pathlib import Path

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from nbdev.showdoc import *
from tqdm import tqdm

from .core import *

#Cell
logger = logging.getLogger(__name__)

#Cell
from sklearn.neighbors import NearestNeighbors
from sklearn.preprocessing import normalize

class KnnRecommender:
    def __init__(
        self,
        word_indexes: List[str],
        embeddings: np.array,
        n_recommendations: int = 10,
        algorithm: str = 'brute'):

        self.word_indexes = word_indexes
        # https://stackoverflow.com/a/34145444 Normalize ensures euclidean will have the same output as cosine
        self.embeddings = normalize(embeddings)
        self._n_recommendations = n_recommendations
        self._algorithm = algorithm

        self.nn_model: NearestNeighbors = None

    def fit(self):
        self.nn_model = NearestNeighbors(n_neighbors=self._n_recommendations+1, algorithm=self._algorithm)
        self.nn_model.fit(self.embeddings)

    def recommend_by_index(self, index: int) -> List[Recommendation]:
        if not self.nn_model:
            raise ValueError('you should call fir() before generating recommendations')
        embedding = self.embeddings[index]
        distances_array, indexes_array = self.nn_model.kneighbors([embedding])
        recommendations = []
        for ind, dist in zip(indexes_array[0][1:], distances_array[0][1:]):
            recommendations.append( Recommendation(movie_id=int(self.word_indexes[ind]), score=dist))
        return recommendations
